package webhook

/*
   This package handles alle the routes and helper-functions used by them
*/
import (
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"sort"

	domeneshopProvider "github.com/vidarno/external-dns-domeneshop-webhook/internal/provider"
)

const (
	mediaTypeFormat      = "application/external.dns.webhook+json;"
	contentTypeHeader    = "Content-Type"
	contentTypePlaintext = "text/plain"
	acceptHeader         = "Accept"
	varyHeader           = "Vary"
)

// Webhook for external dns provider
type Webhook struct {
	provider domeneshopProvider.Provider
}

// New creates a new instance of the Webhook
func New(apiToken, apiSecret string) *Webhook {
	p := domeneshopProvider.NewProvider(apiToken, apiSecret)
	webhook := Webhook{provider: *p}

	return &webhook
}
func (p *Webhook) AdjustEndpoints(w http.ResponseWriter, r *http.Request) {
	// Log the request method and URL path
	fmt.Printf("Received %s request for %s\n", r.Method, r.URL.Path)
	if r.Method != "POST" {
		fmt.Println("Unsupported method")
		w.WriteHeader(http.StatusInternalServerError)
	}

	// TODO: contentTypeHeaderCheck, acceptHeaderCheck

	out, err := p.provider.AdjustEndpoints(r.Body)
	if err != nil {
		w.Header().Set(contentTypeHeader, contentTypePlaintext)
		w.WriteHeader(http.StatusBadRequest)
		errMessage := fmt.Sprintf("failed to decode request body: %v", err)
		if _, writeError := fmt.Fprint(w, errMessage); writeError != nil {
			fmt.Printf("error writing error message to response writer")
		}
		return
	}
	w.Header().Set(contentTypeHeader, string(mediaTypeFormat+"version="+"1"))
	w.Header().Set(varyHeader, contentTypeHeader)
	if _, writeError := fmt.Fprint(w, string(out)); writeError != nil {
		fmt.Printf("error writing response")
	}
	fmt.Println("Tada")
}

// Records handles the GET request for Records and sends POST request for ApplyChanges to applyChanges-function
func (p *Webhook) Records(w http.ResponseWriter, r *http.Request) {
	// Log the request method and URL path
	fmt.Printf("Received %s request for %s\n", r.Method, r.URL.Path)
	// TODO: acceptHeaderCheck

	if r.Method == "POST" {
		err := p.provider.ApplyChanges(r.Body)
		switch err {
		case "StatusBadRequest":
			w.Header().Set(contentTypeHeader, contentTypePlaintext)
			w.WriteHeader(http.StatusBadRequest)
		case "StatusInternalServerError":
			w.Header().Set(contentTypeHeader, contentTypePlaintext)
			w.WriteHeader(http.StatusInternalServerError)
		default:
			w.WriteHeader(http.StatusNoContent)
		}

		return
	}

	records := p.provider.Records()
	w.Header().Set(contentTypeHeader, string(mediaTypeFormat+"version="+"1"))
	w.Header().Set(varyHeader, contentTypeHeader)
	err := json.NewEncoder(w).Encode(records)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

}

// This handler returns DomainFilter and is used on the route for "/""
// TODO: This should either accept a filter passed by environment variables or secrets or be generated by fetching all domains from Domeneshop API
func (p *Webhook) DomainFilter(w http.ResponseWriter, r *http.Request) {
	// Log the request method and URL path
	fmt.Printf("Received %s request for %s\n", r.Method, r.URL.Path)
	// TODO: acceptHeaderCheck

	b, err := DomainFilter{}.MarshalJSON()
	if err != nil {
		fmt.Printf("failed to marshal domain filter, request method: %s, request path: %s", r.Method, r.URL.Path)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Set(contentTypeHeader, string(mediaTypeFormat+"version="+"1"))
	if _, writeError := w.Write(b); writeError != nil {

		fmt.Printf("Failure")
	}
}

type DomainFilter struct {
	regex          *regexp.Regexp
	regexExclusion *regexp.Regexp
	Filters        []string
	exclude        []string
}

// domainFilterSerde is a helper type for serializing and deserializing DomainFilter.
type domainFilterSerde struct {
	Include      []string `json:"include,omitempty"`
	Exclude      []string `json:"exclude,omitempty"`
	RegexInclude string   `json:"regexInclude,omitempty"`
	RegexExclude string   `json:"regexExclude,omitempty"`
}

func (df DomainFilter) MarshalJSON() ([]byte, error) {
	if df.regex != nil || df.regexExclusion != nil {
		var include, exclude string
		if df.regex != nil {
			include = df.regex.String()
		}
		if df.regexExclusion != nil {
			exclude = df.regexExclusion.String()
		}
		return json.Marshal(domainFilterSerde{
			RegexInclude: include,
			RegexExclude: exclude,
		})
	}
	sort.Strings(df.Filters)
	sort.Strings(df.exclude)
	return json.Marshal(domainFilterSerde{
		Include: df.Filters,
		Exclude: df.exclude,
	})
}
